# 1. ERP系统详细设计文档

# 2. 文档修改历史

| 修改人员 | 日期           | 修改原因                                 | 版本号 |
| :------: | :--------------: | :----------------------------------------: | :------: |
|  吴禹廷  | 2022年06月29日 | 创建了详细设计文档          | V1.0   |

# 3. 引言

## 3.1. 编制目的
1. 本报告详细完成对ERP系统的详细设计，达到指导详细设计和开发的⽬的，同时实现和测试⼈员及⽤户的沟通。
2. 本报告⾯向开发⼈员、测试⼈员及最终⽤户⽽编写，是了解系统的导航。

## 3.2. 词汇表
| 词汇名称 | 词汇含义         | 备注 |
| :------: | :----------------: | :----: |
|   ERP   | 企业资源计划 |      |

## 3.3. 参考资料
1. IEEE标准
2. 《软件⼯程与计算（卷⼆）软件开发的技术基础》
3. ERP系统需求规格说明⽂档v1.0
4. ERP系统软件体系结构⽂档v1.0
   
# 4. 产品概述

- 参考ERP系统的⽤例⽂档和软件需求规格说明⽂档中对产品的概括描述。

# 5. 体系结构设计概述

- 参考ERP系统的概要设计⽂档中对体系结构设计的概述

# 6. 结构视角

## 6.1. 业务逻辑层分解

- 业务逻辑层的开发包参⻅软件体系结构⽂档。

### 6.1.1. Accountbl模块

1. 模块概述

   - Accountbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Accountbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了AccountService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。AccountPO是作为账户的持久化对象⽽添加到设计模型中的。

   - Accountbl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-1.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | AccountController | 负责实现账户界面前后端的数据交互 |
    | AccountServiceImpl | 负责实现账户界面的增删改查功能 |
    | AddAccountVO | 账户界面新增账户功能的实现载体，存有姓名和账户余额等信息。 |
    | UpdateAccountVO | 账户界面更新账户功能的实现载体，存有姓名和账户编号等信息。 |
    | Account | 账户界面总功能的实现载体，存有姓名和账户编号等信息。 |

3. 模块内部类的接⼝规范
   
   - Accountbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Account模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">AccountController.add</td>
            <tr><td>语法</td><td>public Response add(AddAccountVO vo);</td></tr>
            <tr><td>前置条件</td><td>姓名输入非空，账户余额非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一个初始账户</td></tr>

        <td rowspan="4">AccountController.del</td>
            <tr><td>语法</td><td>public Response del(Long id)</td></tr>
            <tr><td>前置条件</td><td>账户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>根据账户编号删除对应账户信息</td></tr>

        <td rowspan="4">AccountController.update</td>
            <tr><td>语法</td><td>public Response update(UpdateAccountVO vo)</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>根据值对象中包含的数据更新账户信息</td></tr>

        <td rowspan="4">AccountController.getAll</td>
            <tr><td>语法</td><td>public Response getAll()</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>查找并返回所有账户信息</td></tr>

        </table>

   - Account模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">AccountService.addAccount</td>
            <tr><td>语法</td><td>void addAccount(AddAccountVO vo);</td></tr>
            <tr><td>前置条件</td><td>姓名输入非空，账户余额非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一个初始账户</td></tr>

        <td rowspan="4">AccountService.delAccount</td>
            <tr><td>语法</td><td>void delAccount(Long id);</td></tr>
            <tr><td>前置条件</td><td>账户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>根据账户编号删除对应账户信息</td></tr>

        <td rowspan="4">AccountService.updAccount</td>
            <tr><td>语法</td><td>void updAccount(UpdateAccountVO vo);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>根据值对象中包含的数据更新账户信息</td></tr>

        <td rowspan="4">AccountService.getAllAccount</td>
            <tr><td>语法</td><td>List< AccountVO> getAllAccount();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>查找并返回所有账户信息</td></tr>
        
        <td rowspan="4">AccountService.reduceAccount</td>
            <tr><td>语法</td><td>void reduceAccount(Long bankId, BigDecimal amount);</td></tr>
            <tr><td>前置条件</td><td>银行编号非空，金额非负</td></tr>
            <tr><td>后置条件</td><td>扣除对应账户余额</td></tr>

        <td rowspan="4">AccountService.raiseAccount</td>
            <tr><td>语法</td><td>void raiseAccount(Long bankId, BigDecimal amount);</td></tr>
            <tr><td>前置条件</td><td>银行编号非空，金额非负</td></tr>
            <tr><td>后置条件</td><td>增加对应账户余额</td></tr>

        <td rowspan="4">AccountService.makeAccount</td>
            <tr><td>语法</td><td>Long makeAccount();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统自动生成一个账户并返回账户编号</td></tr>

        </table>

4. 业务逻辑层的动态模型
   
   - 下图表明了在ERP系统中，Account.add的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-account-add.png)


   - 下图表明了在ERP系统中，Account.del的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-account-del.png)


   - 下图表明了在ERP系统中，Account.update的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-account-update.png)


   - 下图表明了在ERP系统中，Account.getAll的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-account-getAll.png)


5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。


### 6.1.2. Annualbl模块

1. 模块概述

   - Annualbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Annualbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了AnnualService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。AnnualPO是作为年终奖的持久化对象⽽添加到设计模型中的。

   - Annualbl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-2.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | AnnualController | 负责实现年终奖界面前后端的数据交互 |
    | AnnualServiceImpl | 负责实现年终奖界面的增删改查功能 |
    | AddAnnualVO | 年终奖界面新增年终奖功能的实现载体，存有姓名和年终奖金额等信息。 |
    | UpdateAnnualVO | 年终奖界面更新年终奖功能的实现载体，存有姓名和年终奖编号等信息。 |
    | Annual | 年终奖界面总功能的实现载体，存有姓名和年终奖编号等信息。 |

3. 模块内部类的接⼝规范
   
   - Annualbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Annual模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">AnnualController.makeAnnual</td>
            <tr><td>语法</td><td>public Response makeAnnual(AnnualVO vo);</td></tr>
            <tr><td>前置条件</td><td>姓名输入非空，年终奖金额非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一条员工年终奖信息</td></tr>

        <td rowspan="4">AnnualController.getAll</td>
            <tr><td>语法</td><td>public Response getAll(Integer year);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>查找并返回所有员工年终奖信息</td></tr>

        </table>

   - Annual模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">AnnualService.makeAnnual</td>
            <tr><td>语法</td><td>void makeAnnual(AnnualVO vo);</td></tr>
            <tr><td>前置条件</td><td>年终奖金额非负，年终奖发放年份非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的金额和年份为一个员工制定年终奖</td></tr>

        <td rowspan="4">AnnualService.getAnnual</td>
            <tr><td>语法</td><td>BigDecimal getAnnual(Integer uid, Integer year);</td></tr>
            <tr><td>前置条件</td><td>员工编号输入非空，年份输入非负</td></tr>
            <tr><td>后置条件</td><td>系统返回该员工对应年份的年终奖金额</td></tr>

        <td rowspan="4">AnnualService.checkAnnual</td>
            <tr><td>语法</td><td>boolean checkAnnual(Integer uid, Integer year);</td></tr>
            <tr><td>前置条件</td><td>员工编号输入非空，年份输入非负</td></tr>
            <tr><td>后置条件</td><td>系统查询该员工对应年份有无年终奖</td></tr>

        <td rowspan="4">AnnualService.selectByAnnualId</td>
            <tr><td>语法</td><td>AnnualPO selectByAnnualId(String AnnualId);</td></tr>
            <tr><td>前置条件</td><td>输入年终奖编号非空</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回对应编号的年终奖</td></tr>

        <td rowspan="4">AnnualService.getUserWithoutAnnual</td>
            <tr><td>语法</td><td>List< Integer> getUidWithoutAnnual(Integer year);</td></tr>
            <tr><td>前置条件</td><td>输入年份非负</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回指定年份尚未发放年终奖的员工</td></tr>

        </table>

4. 业务逻辑层的动态模型
   
   - 下图表明了在ERP系统中，Annual.makeAnnual的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-annual-makeAnnual.png)


   - 下图表明了在ERP系统中，Annual.getAll的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-annual-getAll.png)


5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。



### 6.1.3. Paymentbl模块

1. 模块概述

   - Paymentbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Paymentbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了PaymentService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。PaymentPO是作为付款单的持久化对象⽽添加到设计模型中的。

   - Paymentbl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-3.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | PaymentController | 负责实现付款单界面前后端的数据交互 |
    | PaymentServiceImpl | 负责实现付款单界面的增删改查功能 |
    | AddPaymentVO | 付款单界面新增付款单功能的实现载体，存有姓名和付款单金额等信息。 |
    | UpdatePaymentVO | 付款单界面更新付款单功能的实现载体，存有客户姓名和付款单编号等信息。 |
    | Payment | 付款单界面总功能的实现载体，存有客户姓名和付款单编号等信息。 |

3. 模块内部类的接⼝规范
   
   - Paymentbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Payment模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">PaymentController.makePurchaseOrder</td>
            <tr><td>语法</td><td>public Response makePurchaseOrder(PaymentVO vo);</td></tr>
            <tr><td>前置条件</td><td>付款单编号，银行编号和操作员姓名输入非空，金额输入非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一张付款单</td></tr>

        <td rowspan="4">PaymentController.approval</td>
            <tr><td>语法</td><td>public Response approval(String PaymentId, AccountSheetState state) </td></tr>
            <tr><td>前置条件</td><td>付款单编号输入非空，输入状态为“审批通过/失败”</td></tr>
            <tr><td>后置条件</td><td>根据付款单编号修改对应付款单状态</td></tr>

        <td rowspan="4">PaymentController.showSheetByState</td>
            <tr><td>语法</td><td>public Response showSheetByState(AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>输入状态非空</td></tr>
            <tr><td>后置条件</td><td>根据输入状态筛选并返回符合条件的付款单信息</td></tr>

        </table>

   - Payment模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">PaymentService.makeSheet</td>
            <tr><td>语法</td><td>void makeSheet(PaymentVO vo);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一个付款单</td></tr>

        <td rowspan="4">PaymentService.approval</td>
            <tr><td>语法</td><td>void approval(String PaymentId, AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>付款单编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统将该付款单的审批状态设为输入的状态</td></tr>

        <td rowspan="4">PaymentService.findSheetByState</td>
            <tr><td>语法</td><td>List< PaymentVO> findSheetByState(AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的状态查找并返回所有付款单信息</td></tr>

        <td rowspan="4">PaymentService.selectByPaymentId</td>
            <tr><td>语法</td><td>PaymentPO selectByPaymentId(String PaymentId);</td></tr>
            <tr><td>前置条件</td><td>付款单编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回编号对应的付款单信息</td></tr>

        </table>

4. 业务逻辑层的动态模型
   
   - 下图表明了在ERP系统中，Payment.makePurchaseOrder的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-FKD-makePurchaseOrder.png)


   - 下图表明了在ERP系统中，Payment.approval的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-FKD-approval.png)


   - 下图表明了在ERP系统中，Payment.showSheetByState的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-FKD-showSheetByState.png)


5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。



### 6.1.4. Wagebl模块

1. 模块概述

   - Wagebl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Wagebl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了WageService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。WagePO是作为工资单的持久化对象⽽添加到设计模型中的。

   - Wagebl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-4.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | WageController | 负责实现工资单界面前后端的数据交互 |
    | WageServiceImpl | 负责实现工资单界面的增删改查功能 |
    | AddWageVO | 工资单界面新增工资单功能的实现载体，存有员工姓名和工资单金额等信息。 |
    | UpdateWageVO | 工资单界面更新工资单功能的实现载体，存有员工姓名和工资单编号等信息。 |
    | Wage | 工资单界面总功能的实现载体，存有员工姓名和工资单编号等信息。 |

3. 模块内部类的接⼝规范
   
   - Wagebl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Wage模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">WageController.makeSheet</td>
            <tr><td>语法</td><td>makeSheet(UserAndDateVO vo);</td></tr>
            <tr><td>前置条件</td><td>输入年份非负，月份为1至12之间，输入员工编号非空</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一个初始工资单</td></tr>

        <td rowspan="4">WageController.approval</td>
            <tr><td>语法</td><td>public Response approval(String WageId, AccountSheetState state)</td></tr>
            <tr><td>前置条件</td><td>工资单编号输入非空，状态为“审批成功/失败”</td></tr>
            <tr><td>后置条件</td><td>根据工资单编号修改对应工资单状态</td></tr>

        <td rowspan="4">WageController.transfer</td>
            <tr><td>语法</td><td>transfer(String WageId, AccountSheetState state)</td></tr>
            <tr><td>前置条件</td><td>工资单编号输入非空，状态为“审批失败/已发放工资”</td></tr>
            <tr><td>后置条件</td><td>根据工资单编号修改对应工资单状态</td></tr>

        <td rowspan="4">WageController.showSheetByState</td>
            <tr><td>语法</td><td>public Response showSheetByState(AccountSheetState state)</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入状态查找并返回符合条件的工资单信息</td></tr>

        <td rowspan="4">WageController.getUser</td>
            <tr><td>语法</td><td>public Response getUser(DateVO vo)</td></tr>
            <tr><td>前置条件</td><td>输入年份非负，月份为1至12之间</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回输入月份未发放工资的员工编号</td></tr>

        <td rowspan="4">WageController.getYearlyTotal</td>
            <tr><td>语法</td><td>public Response getYearlyTotal(Integer uid, Integer year)</td></tr>
            <tr><td>前置条件</td><td>输入年份非负，输入员工编号非空</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回该年员工的工资总额</td></tr>

        </table>

   - Wage模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">WageService.makeSheet</td>
            <tr><td>语法</td><td>void makeSheet(UserAndDateVO vo);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的用户和时间生成一个员工工资单</td></tr>

        <td rowspan="4">WageService.approval</td>
            <tr><td>语法</td><td>void approval(String WageId, AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>员工工资单编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统将该员工工资单的审批状态设为输入的状态</td></tr>

        <td rowspan="4">WageService.findSheetByState</td>
            <tr><td>语法</td><td>List< WageVO> findSheetByState(AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的状态查找并返回所有员工工资单信息</td></tr>

        <td rowspan="4">WageService.selectByWageId</td>
            <tr><td>语法</td><td>WagePO selectByWageId(String WageId);</td></tr>
            <tr><td>前置条件</td><td>输入工资单编号非空</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回对应编号的工资单</td></tr>

        <td rowspan="4">WageService.getUserWithoutPayroll</td>
            <tr><td>语法</td><td>WagePO getUserWithoutPayroll(DateVO vo);</td></tr>
            <tr><td>前置条件</td><td>输入年份非负，月份为1至12之间</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回指定月份尚未发放工资的员工</td></tr>

        <td rowspan="4">WageService.getYearlyTotal</td>
            <tr><td>语法</td><td>YearlyTotalWithAnnualVO getYearlyTotal(Integer uid, Integer year);</td></tr>
            <tr><td>前置条件</td><td>输入员工编号非空，年份非负</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回对应编号员工该年份的工资单</td></tr>

        <td rowspan="4">WageService.getYearlyTotalSalary</td>
            <tr><td>语法</td><td>BigDecimal getYearlyTotalSalary(Integer uid, Integer year);</td></tr>
            <tr><td>前置条件</td><td>输入员工编号非空，年份非负</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回该员工指定年份的工资总额</td></tr>

        </table>

4. 业务逻辑层的动态模型
   
   - 下图表明了在ERP系统中，Wage.makeSheet的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-GZD-makeSheet.png)


   - 下图表明了在ERP系统中，Wage.approval的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-GZD-approval.png)


   - 下图表明了在ERP系统中，Wage.transfer的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-GZD-transfer.png)


   - 下图表明了在ERP系统中，Wage.showSheetByState的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-GZD-showSheetByState.png)

   - 下图表明了在ERP系统中，Wage.getUser的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-GZD-getUser.png)


   - 下图表明了在ERP系统中，Wage.getYearlyTotal的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-GZD-getYearlyTotal.png)


5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。



### 6.1.5. Salarybl模块

1. 模块概述

   - Salarybl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Salarybl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了SalaryService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。SalaryPO是作为员工工资信息的持久化对象⽽添加到设计模型中的。

   - Salarybl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-5.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | SalaryController | 负责实现员工工资界面前后端的数据交互 |
    | SalaryServiceImpl | 负责实现员工工资界面的增删改查功能 |
    | AddSalaryVO | 员工工资界面新增员工工资功能的实现载体，存有员工姓名和员工工资金额等信息。 |
    | UpdateSalaryVO | 员工工资界面更新工资功能的实现载体，存有员工姓名和员工工资编号等信息。 |
    | Salary | 员工工资界面总功能的实现载体，存有员工姓名和员工工资编号等信息。 |

3. 模块内部类的接⼝规范
   
   - Salarybl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Salary模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">SalaryController.getAll</td>
            <tr><td>语法</td><td>Response getAll();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回所有员工的工资信息</td></tr>

        <td rowspan="4">SalaryController.upd</td>
            <tr><td>语法</td><td>Response upd(SalaryFullVO vo)</td></tr>
            <tr><td>前置条件</td><td>员工编号输入非空，岗位津贴非负</td></tr>
            <tr><td>后置条件</td><td>根据员工编号修改对应员工工资状态</td></tr>

        </table>

   - Salary模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">SalaryService.getSalary</td>
            <tr><td>语法</td><td>Salary getSalary(Role r);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的用户岗位返回对应的工资</td></tr>

        <td rowspan="4">SalaryService.addBonus</td>
            <tr><td>语法</td><td>void addBonus(String name);</td></tr>
            <tr><td>前置条件</td><td>员工姓名输入非空</td></tr>
            <tr><td>后置条件</td><td>系统根据姓名返回该员工对应工资</td></tr>

        <td rowspan="4">SalaryService.getMonthlyBonus</td>
            <tr><td>语法</td><td>BigDecimal getMonthlyBonus(User user, int year, int month);</td></tr>
            <tr><td>前置条件</td><td>年份非负，月份为1至12之间</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的员工姓名和月份返回该月工资</td></tr>

        <td rowspan="4">SalaryService.getAllSalary</td>
            <tr><td>语法</td><td>List< SalaryFullVO> getAllSalary();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统返回所有员工的工资信息</td></tr>

        <td rowspan="4">SalaryService.upd</td>
            <tr><td>语法</td><td>void upd(SalaryFullVO vo);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入更新员工工资信息</td></tr>

        </table>

4. 业务逻辑层的动态模型
   
   - 下图表明了在ERP系统中，Salary.getAll的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-salary-getAll.png)


   - 下图表明了在ERP系统中，Salary.upd的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-salary-upd.png)


5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。



### 6.1.6. Signupbl模块

1. 模块概述

   - Signupbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Signupbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了SignupService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。SignupPO是作为打卡的持久化对象⽽添加到设计模型中的。

   - Signupbl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-6.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | SignupController | 负责实现打卡界面前后端的数据交互 |
    | SignupServiceImpl | 负责实现打卡界面的增删改查功能 |
    | AddSignupVO | 打卡界面新增打卡功能的实现载体，存有员工姓名，打卡时间以及打卡次数等信息。 |
    | UpdateSignupVO | 打卡界面更新打卡功能的实现载体，存有员工姓名和打卡记录等信息。 |
    | Signup | 打卡界面总功能的实现载体，存有员工姓名和打卡记录等信息。 |

3. 模块内部类的接⼝规范
   
   - Signupbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Signup模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">SignupController.tick</td>
            <tr><td>语法</td><td>Response tick(Integer uid);</td></tr>
            <tr><td>前置条件</td><td>输入员工编号非空</td></tr>
            <tr><td>后置条件</td><td>系统新增一条该员工的打卡记录</td></tr>

        <td rowspan="4">SignupController.check</td>
            <tr><td>语法</td><td>Response check(Integer uid)</td></tr>
            <tr><td>前置条件</td><td>员工编号输入非空</td></tr>
            <tr><td>后置条件</td><td>查询该员工今日是否已经打卡</td></tr>

        </table>

   - Signup模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">SignupService.tick</td>
            <tr><td>语法</td><td>void tick(Integer uid);</td></tr>
            <tr><td>前置条件</td><td>员工编号非负</td></tr>
            <tr><td>后置条件</td><td>系统新增一条该编号对应员工的打卡记录</td></tr>

        <td rowspan="4">SignupService.checkDailyTick</td>
            <tr><td>语法</td><td>boolean checkDailyTick(Integer uid);</td></tr>
            <tr><td>前置条件</td><td>员工编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查询对应编号员工当日是否打卡</td></tr>

        <td rowspan="4">SignupService.MonthlyTickTimes</td>
            <tr><td>语法</td><td>Integer MonthlyTickTimes(Integer uid);</td></tr>
            <tr><td>前置条件</td><td>员工编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查询对应编号员工当月打卡次数</td></tr>

        <td rowspan="4">SignupService.absentTimes</td>
            <tr><td>语法</td><td>Integer absentTimes(Integer uid);</td></tr>
            <tr><td>前置条件</td><td>员工编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查询对应编号员工当月缺勤次数</td></tr>

        </table>


4. 业务逻辑层的动态模型
   
   - 下图表明了在ERP系统中，Signup.tick的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-signup-tick.png)


   - 下图表明了在ERP系统中，Signup.check的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-signup-check.png)


5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。



### 6.1.7. Creditbl模块

1. 模块概述

   - Creditbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Creditbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了CreditService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。CreditPO是作为收款单的持久化对象⽽添加到设计模型中的。

   - Creditbl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-7.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | CreditController | 负责实现收款单界面前后端的数据交互 |
    | CreditServiceImpl | 负责实现收款单界面的增删改查功能 |
    | AddCreditVO | 收款单界面新增收款单功能的实现载体，存有姓名和收款单金额等信息。 |
    | UpdateCreditVO | 收款单界面更新收款单功能的实现载体，存有客户姓名和收款单编号等信息。 |
    | Credit | 收款单界面总功能的实现载体，存有客户姓名和收款单编号等信息。 |

3. 模块内部类的接⼝规范
   
   - Creditbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Credit模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">CreditController.makePurchaseOrder</td>
            <tr><td>语法</td><td>public Response makePurchaseOrder(CreditVO vo);</td></tr>
            <tr><td>前置条件</td><td>收款单编号，银行编号和操作员姓名输入非空，金额输入非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一个收款单</td></tr>

        <td rowspan="4">CreditController.approval</td>
            <tr><td>语法</td><td>public Response approval(String CreditId, AccountSheetState state) </td></tr>
            <tr><td>前置条件</td><td>收款单编号输入非空，输入状态为“审批通过/失败”</td></tr>
            <tr><td>后置条件</td><td>根据收款单编号修改对应收款单状态</td></tr>

        <td rowspan="4">CreditController.showSheetByState</td>
            <tr><td>语法</td><td>public Response showSheetByState(AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>输入状态非空</td></tr>
            <tr><td>后置条件</td><td>根据输入状态筛选并返回符合条件的收款单信息</td></tr>

        </table>

   - Credit模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">CreditService.makeSheet</td>
            <tr><td>语法</td><td>void makeSheet(CreditVO vo);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的信息生成一个收款单</td></tr>

        <td rowspan="4">CreditService.approval</td>
            <tr><td>语法</td><td>void approval(String CreditId, AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>收款单编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统将该收款单的审批状态设为输入的状态</td></tr>

        <td rowspan="4">CreditService.findSheetByState</td>
            <tr><td>语法</td><td>List< CreditVO> findSheetByState(AccountSheetState state);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的状态查找并返回所有收款单信息</td></tr>

        <td rowspan="4">CreditService.selectByCreditId</td>
            <tr><td>语法</td><td>CreditPO selectByCreditId(String CreditId);</td></tr>
            <tr><td>前置条件</td><td>收款单编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回编号对应的收款单信息</td></tr>

        </table>

4. 业务逻辑层的动态模型
   
   - 下图表明了在ERP系统中，Credit.makePurchaseOrder的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-SKD-makePurchaseOrder.png)


   - 下图表明了在ERP系统中，Credit.approval的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-SKD-approval.png)


   - 下图表明了在ERP系统中，Credit.showSheetByState的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-SKD-showSheetByState.png)

5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。



### 6.1.8. Userbl模块

1. 模块概述

   - Userbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Userbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了UserService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。User是作为用户的持久化对象⽽添加到设计模型中的。

   - Userbl模块的设计如下图

    ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-detail-8.png)

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | UserController | 负责实现用户界面前后端的数据交互 |
    | UserServiceImpl | 负责实现用户界面的增删改查功能 |
    | AddUserVO | 用户界面新增用户功能的实现载体，存有姓名和用户余额等信息。 |
    | UpdateUserVO | 用户界面更新用户功能的实现载体，存有姓名和用户编号等信息。 |
    | User | 用户界面总功能的实现载体，存有姓名和用户编号等信息。 |

3. 模块内部类的接⼝规范
   
   - Userbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - User模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">UserController.enroll</td>
            <tr><td>语法</td><td>Response enroll(EnrollmentVO vo);</td></tr>
            <tr><td>前置条件</td><td>姓名输入非空</td></tr>
            <tr><td>后置条件</td><td>系统新增一个初始员工</td></tr>

        <td rowspan="4">UserController.upd</td>
            <tr><td>语法</td><td>Response upd(EnrollmentVO vo);</td></tr>
            <tr><td>前置条件</td><td>用户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>根据值对象中包含的数据更新用户信息</td></tr>

        <td rowspan="4">UserController.del</td>
            <tr><td>语法</td><td>Response del(Integer id);</td></tr>
            <tr><td>前置条件</td><td>用户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>根据用户编号删除对应用户信息</td></tr>

        <td rowspan="4">UserController.getAll</td>
            <tr><td>语法</td><td>Response getAll()</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>查找并返回所有用户信息</td></tr>

        <td rowspan="4">UserController.getId</td>
            <tr><td>语法</td><td>Response getId(String name);</td></tr>
            <tr><td>前置条件</td><td>姓名输入非空</td></tr>
            <tr><td>后置条件</td><td>查找并返回该姓名对应的用户编号</td></tr>

        </table>

   - User模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">UserService.login</td>
            <tr><td>语法</td><td>Map< String, String> login(UserVO userVO);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>用户登录</td></tr>

        <td rowspan="4">UserService.register</td>
            <tr><td>语法</td><td>void register(UserVO userVO);</td></tr>
            <tr><td>前置条件</td><td>用户名与密码输入非空</td></tr>
            <tr><td>后置条件</td><td>系统根据输入信息创建该用户</td></tr>

        <td rowspan="4">UserService.auth</td>
            <tr><td>语法</td><td>UserVO auth(String token);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>用户授权</td></tr>

        <td rowspan="4">UserService.enrollment</td>
            <tr><td>语法</td><td>UserFullVO enrollment(EnrollmentVO userVO);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统添加该用户的入职信息</td></tr>

        <td rowspan="4">UserService.getAllDetail</td>
            <tr><td>语法</td><td>UserFullVO getAllDetail(Integer id);</td></tr>
            <tr><td>前置条件</td><td>用户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统返回该用户所有信息</td></tr>

        <td rowspan="4">UserService.update</td>
            <tr><td>语法</td><td>UserFullVO update(EnrollmentVO userVO);</td></tr>
            <tr><td>前置条件</td><td>新用户名与旧用户名不重复</td></tr>
            <tr><td>后置条件</td><td>系统更改用户信息</td></tr>

        <td rowspan="4">UserService.del</td>
            <tr><td>语法</td><td>void del(Integer id);</td></tr>
            <tr><td>前置条件</td><td>用户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统删除编号对应用户</td></tr>

        <td rowspan="4">UserService.getAll</td>
            <tr><td>语法</td><td>List< EnrollmentVO> getAll();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统返回所有用户的所有信息</td></tr>

        <td rowspan="4">UserService.getIdByName</td>
            <tr><td>语法</td><td>Integer getIdByName(String name);</td></tr>
            <tr><td>前置条件</td><td>用户名输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查询并返回用户名对应用户编号</td></tr>

        <td rowspan="4">UserService.getUserById</td>
            <tr><td>语法</td><td>User getUserById(Integer id);</td></tr>
            <tr><td>前置条件</td><td>用户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查询并返回用户编号对应用户</td></tr>

        <td rowspan="4">UserService.getAllUserNotIn</td>
            <tr><td>语法</td><td>List< Integer> getAllUserNotIn(List< Integer> ids);</td></tr>
            <tr><td>前置条件</td><td>用户编号输入非空</td></tr>
            <tr><td>后置条件</td><td>系统查询并返回不在该编号列表中的所有剩余用户编号</td></tr>

        </table>


4. 业务逻辑层的动态模型

   - 下图表明了在ERP系统中，User.enroll的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-user-enroll.png)


   - 下图表明了在ERP系统中，User.upd的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-user-upd.png)


   - 下图表明了在ERP系统中，User.del的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-user-del.png)


   - 下图表明了在ERP系统中，User.getAll的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-user-getAll.png)


   - 下图表明了在ERP系统中，User.getId的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-user-getId.png)


5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。


### 6.1.9. Budgetbl模块

1. 模块概述

   - Budgetbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Budgetbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了BudgetService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。Budget是作为优惠策略的持久化对象⽽添加到设计模型中的。

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | BudgetController | 负责实现优惠策略界面前后端的数据交互 |
    | BudgetServiceImpl | 负责实现优惠策略界面的增删改查功能 |
    | AmountDiscountVO | 优惠策略界面新增基于总金额的折扣功能的实现载体，存有折扣门槛和折扣比例等信息。 |
    | AmountOffsetVO | 优惠策略界面新增基于总金额的代金券功能的实现载体，存有折扣门槛和代金券金额等信息 |
    | LevelDiscountVO | 优惠策略界面新增基于用户等级的折扣功能的实现载体，存有用户等级和折扣比例等信息。 |
    | LevelOffsetVO | 优惠策略界面新增基于用户等级的代金券功能的实现载体，存有用户等级和代金券金额等信息 |
    | AmountDiscountPO | 优惠策略界面新增基于总金额的折扣功能的实现载体，存有折扣门槛和折扣比例等信息。 |
    | AmountOffsetPO | 优惠策略界面新增基于总金额的代金券功能的实现载体，存有折扣门槛和代金券金额等信息 |
    | LevelDiscountPO | 优惠策略界面新增基于用户等级的折扣功能的实现载体，存有用户等级和折扣比例等信息。 |
    | LevelOffsetPO | 优惠策略界面新增基于用户等级的代金券功能的实现载体，存有用户等级和代金券金额等信息 |

3. 模块内部类的接⼝规范
   
   - Budgetbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Budget模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">BudgetController.amountdiscount</td>
            <tr><td>语法</td><td>Response amountdiscount(AmountDiscountVO vo);</td></tr>
            <tr><td>前置条件</td><td>门槛金额非负，折扣比例为0至1之间</td></tr>
            <tr><td>后置条件</td><td>系统根据输入新增一种基于总金额的折扣信息</td></tr>

        <td rowspan="4">BudgetController.amountoffset</td>
            <tr><td>语法</td><td>Response amountoffset(AmountOffsetVO vo);</td></tr>
            <tr><td>前置条件</td><td>门槛金额非负，代金券金额非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入新增一种基于总金额的代金券信息</td></tr>

        <td rowspan="4">BudgetController.leveldiscount</td>
            <tr><td>语法</td><td>Response leveldiscount(levelDiscountVO vo);</td></tr>
            <tr><td>前置条件</td><td>用户等级非负，折扣比例为0至1之间</td></tr>
            <tr><td>后置条件</td><td>系统根据输入新增一种基于用户等级的折扣信息</td></tr>

        <td rowspan="4">BudgetController.leveloffset</td>
            <tr><td>语法</td><td>Response leveloffset(levelOffsetVO vo);</td></tr>
            <tr><td>前置条件</td><td>用户等级非负，代金券金额非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入新增一种基于用户等级的代金券信息</td></tr>

        <td rowspan="4">BudgetController.getamountdiscount</td>
            <tr><td>语法</td><td>Response getamountdiscount();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回所有基于总金额的折扣策略信息</td></tr>

        <td rowspan="4">BudgetController.getamountoffset</td>
            <tr><td>语法</td><td>Response getamountoffset();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回所有基于总金额的代金券策略信息</td></tr>

        <td rowspan="4">BudgetController.getleveldiscount</td>
            <tr><td>语法</td><td>Response getleveldiscount();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回所有基于用户等级的折扣策略信息</td></tr>

        <td rowspan="4">BudgetController.getleveloffset</td>
            <tr><td>语法</td><td>Response getleveloffset();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回所有基于用户等级的代金券策略信息</td></tr>

        </table>

   - Budget模块的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">BudgetService.amountdiscount</td>
            <tr><td>语法</td><td>void amountdiscount(AmountDiscountVO vo);</td></tr>
            <tr><td>前置条件</td><td>折扣比例应为0至1之间，门槛非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入折扣添加一个优惠策略</td></tr>

        <td rowspan="4">BudgetService.amountoffset</td>
            <tr><td>语法</td><td>void amountoffset(AmountOffsetVO vo);</td></tr>
            <tr><td>前置条件</td><td>代金券金额非负，门槛非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入金额添加一个代金券</td></tr>

        <td rowspan="4">BudgetService.leveldiscount</td>
            <tr><td>语法</td><td>void leveldiscount(LevelDiscountVO vo);</td></tr>
            <tr><td>前置条件</td><td>折扣比例应为0至1之间，用户等级非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入折扣添加一个优惠策略</td></tr>

        <td rowspan="4">BudgetService.leveloffset</td>
            <tr><td>语法</td><td>void leveloffset(LevelOffsetVO vo);</td></tr>
            <tr><td>前置条件</td><td>代金券金额非负，用户等级非负</td></tr>
            <tr><td>后置条件</td><td>系统根据输入金额添加一个代金券</td></tr>

        <td rowspan="4">BudgetService.getamountdiscount</td>
            <tr><td>语法</td><td>List< AmountDiscountPO> getamountdiscount();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查询并返回所有基于总金额的折扣信息</td></tr>

        <td rowspan="4">BudgetService.getamountoffset</td>
            <tr><td>语法</td><td>ist< AmountOffsetPO> getamountoffset();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查询并返回所有基于总金额的代金券信息</td></tr>

        <td rowspan="4">BudgetService.getleveldiscount</td>
            <tr><td>语法</td><td>List< LevelDiscountPO> getleveldiscount();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查询并返回所有基于用户等级的折扣信息</td></tr>

        <td rowspan="4">BudgetService.getleveloffset</td>
            <tr><td>语法</td><td>List< LevelDiscountPO> getleveloffset();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查询并返回所有基于用户等级的代金券信息</td></tr>

        </table>


4. 业务逻辑层的动态模型

   - 下图表明了在ERP系统中，Budget.amountdiscount的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-amountdiscount.png)


   - 下图表明了在ERP系统中，Budget.amountoffset的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-amountoffset.png)



   - 下图表明了在ERP系统中，Budget.leveldiscount的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-leveldiscount.png)


   - 下图表明了在ERP系统中，Budget.leveloffset的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-leveloffset.png)


   - 下图表明了在ERP系统中，Budget.getamountdiscount的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-getamountdiscount.png)


   - 下图表明了在ERP系统中，Budget.getamountoffset的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-getamountoffset.png)



   - 下图表明了在ERP系统中，Budget.getleveldiscount的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-getleveldiscount.png)


   - 下图表明了在ERP系统中，Budget.getleveloffset的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-budget-getleveloffset.png)



5. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。


### 6.1.10. BusinessPositionbl模块

1. 模块概述

   - BusinessPositionbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - BusinessPositionbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了BusinessPositionService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。BusinessPositionPO是作为用户的持久化对象⽽添加到设计模型中的。

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | BusinessPositionController | 负责实现经营情况界面前后端的数据交互 |
    | BusinessPositionServiceImpl | 负责实现经营情况界面的增删改查功能 |
    | BusinessPositionVO | 经营情况界面功能的实现载体，存有公司经营情况等信息。 |

3. 模块内部类的接⼝规范
   
   - BusinessPositionbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - BusinessPosition模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">BusinessPositionController.getBusinessPosition</td>
            <tr><td>语法</td><td>Response getBusinessPosition(String beginDateStr, String endDateStr);</td></tr>
            <tr><td>前置条件</td><td>起始日期不大于结束日期</td></tr>
            <tr><td>后置条件</td><td>系统返回该时间段公司经营情况</td></tr>

        </table>

   - BusinessPosition模块的服务接口规范
  
    <table>
        <tr><th colspan = "3">提供的服务(供接口)</th></tr>

    <td rowspan="4">BusinessPositionService.getBusinessPosition</td>
        <tr><td>语法</td><td>BusinessPositionVO getBusinessPosition(String beginDateStr, String endDateStr);</td></tr>
        <tr><td>前置条件</td><td>起始日期不大于结束日期</td></tr>
        <tr><td>后置条件</td><td>系统查找并返回指定时间段的经营情况表</td></tr>

    </table>


1. 业务逻辑层的动态模型

   - 下图表明了在ERP系统中，BusinessPosition.getBusinessPosition的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-bp-getBusinessPosition.png)


2. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。


### 6.1.11. SaleDetailbl模块

1. 模块概述

   - SaleDetailbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - SaleDetailbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。每⼀层为了增加灵活性，我们会添加接⼝。⽐如展示层和业务逻辑层之间，我们设置了SaleDetailService接⼝。业务逻辑层和数据层之间设置了Dao接⼝。SaleDetailPO是作为用户的持久化对象⽽添加到设计模型中的。

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | SaleDetailController | 负责实现销售明细界面前后端的数据交互 |
    | SaleDetailServiceImpl | 负责实现销售明细界面的增删改查功能 |
    | SaleDetailVO | 销售明细界面功能的实现载体，存有公司销售明细等信息。 |

3. 模块内部类的接⼝规范
   
   - SaleDetailbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - SaleDetail模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">SaleDetailController.getSaleDetailList</td>
            <tr><td>语法</td><td>Response getSaleDetailList(String salesman, String customer, String pname, String beginDateStr, String endDateStr);</td></tr>
            <tr><td>前置条件</td><td>起始日期不大于结束日期</td></tr>
            <tr><td>后置条件</td><td>系统返回该时间段公司销售明细</td></tr>

        </table>

   - SaleDetail模块的服务接口规范
  
        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">SaleDetailService.getSaleDetailList</td>
            <tr><td>语法</td><td>List< SaleDetailVO> getSaleDetailList(String salesman, String customer, String pname, String beginDateStr, String endDateStr);</td></tr>
            <tr><td>前置条件</td><td>销售员、客户等姓名输入非空，起始日期不大于结束日期</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回指定时间段的销售明细表</td></tr>

        <td rowspan="4">SaleDetailService.download</td>
            <tr><td>语法</td><td>void download(HttpServletResponse response, String salesman, String customer, String pname, String beginDateStr, String endDateStr);</td></tr>
            <tr><td>前置条件</td><td>销售员、客户等姓名输入非空，起始日期不大于结束日期</td></tr>
            <tr><td>后置条件</td><td>系统查找并下载指定时间段的销售明细表</td></tr>

        <td rowspan="4">SaleDetailService.getWorkBook</td>
            <tr><td>语法</td><td>private Workbook getWorkbook(String salesman, String customer, String pname, String beginDateStr, String endDateStr);</td></tr>
            <tr><td>前置条件</td><td>销售员、客户等姓名输入非空，起始日期不大于结束日期</td></tr>
            <tr><td>后置条件</td><td>系统查找并保存指定时间段的销售明细表为表格形式文件</td></tr>

        </table>


4. 业务逻辑层的动态模型

   - 下图表明了在ERP系统中，SaleDetail.getSaleDetail的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-sd-getSaleDetailList.png)


2. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。


### 6.1.12. Initialbl模块

1. 模块概述

   - Initialbl模块承担的需求参⻅需求规格说明⽂档功能需求及相关⾮功能需求说明⽂档。
   - Initialbl模块的职责及接⼝参⻅软件系统结构描述⽂档。

2. 整体结构

   - 根据体系结构的设计，我们将系统分为了前端展示层、Controller层、业务逻辑层、数据层。Initial_AccountPO, Initial_CustomerPO, Initial_ProductPO是作为用户的持久化对象⽽添加到设计模型中的。

   - 各个类的职责：
  
    |   模块   |   职责   |
    |  :--------:   |   -------    |
    | InitialController | 负责实现销售明细界面前后端的数据交互 |


3. 模块内部类的接⼝规范
   
   - Initialbl模块的各个类的职责和内部类的接⼝规范已在ERP系统软件体系结构⽂档中描述。
   - Initial模块的接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">InitialController.create</td>
            <tr><td>语法</td><td>Response create(HttpServletResponse response);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统进行期初建账操作</td></tr>

        </table>

   - Customer模块涉及initialController的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">CustomerService.getInitialCustomersByType</td>
            <tr><td>语法</td><td>List< Initial_CustomerPO> getInitialCustomersByType(CustomerType type);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统根据输入的类型筛选并返回符合条件的预设客户信息</td></tr>

        <td rowspan="4">CustomerService.initial_create</td>
            <tr><td>语法</td><td>void initial_create();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统将预设客户信息加入系统</td></tr>

        </table>

   - Product模块涉及initialController的服务接口规范

        <table>
            <tr><th colspan = "3">提供的服务(供接口)</th></tr>

        <td rowspan="4">ProductService.initial_createProduct</td>
            <tr><td>语法</td><td>void initial_createProduct(CreateProductVO inputVO);</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统将预设商品信息加入系统</td></tr>

        <td rowspan="4">ProductService.initialcreate</td>
            <tr><td>语法</td><td>void initialcreate();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统增加一个初始预设商品</td></tr>

        <td rowspan="4">ProductService.queryAllInitialProduct</td>
            <tr><td>语法</td><td>List< ProductInfoVO> queryAllInitialProduct();</td></tr>
            <tr><td>前置条件</td><td>无</td></tr>
            <tr><td>后置条件</td><td>系统查找并返回所有预设商品信息</td></tr>

        </table>


1. 业务逻辑层的动态模型

   - 下图表明了在ERP系统中，Initial.create的相关对象之间的协作。
  ![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-initial-create.png)


2. 业务逻辑层的设计原理
   
   - 利⽤委托式控制⻛格，每个界⾯需要访问的业务逻辑由各⾃的控制器委托给不同的领域对象。



# 7. 依赖视角

 - 下图分别是前端和后端各⾃的包之间的依赖关系。

![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-03.png)

![](https://seec-homework.oss-cn-shanghai.aliyuncs.com/201250031-lab7-04.png)